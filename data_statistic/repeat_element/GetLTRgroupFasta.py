#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os
import re
import sys
import logging
import argparse
from Bio import SeqIO


def read_genome_fasta(genome_fasta_path):
    with open(genome_fasta_path, 'r') as genome_fasta:
        genome_dict = SeqIO.to_dict(SeqIO.parse(genome_fasta, "fasta"))
    return genome_dict


def read_ltr_clade(cls_file_path):
    ltr_clade_dict = {"start": {}, "end": {}}
    with open(cls_file_path, "r") as cls_file:
        for line in cls_file:
            if line.startswith("#"):
                continue
            name_raw, clade = line.strip().split()[0], line.strip().split()[3]
            name = re.search(r"(.*?)[#_][LCs]", name_raw).group(1)
            chr_id, start, end = re.search(r".*_(\w+\d+):(\d+)\.\.(\d+)#.*", name_raw).group(1, 2, 3)
            ltr_clade_dict["start"][(name, chr_id, int(start))] = clade
            ltr_clade_dict["end"][(name, chr_id, int(end))] = clade
    return ltr_clade_dict


def get_fasta_by_coord(chr_i, start_coord, end_coord, db):
    chr_seq = db[chr_i].seq
    target_seq = chr_seq[start_coord - 1:end_coord]
    return target_seq


def read_ltr_pairs(te_gff_file_path, genome_fasta_path, cls_file_path):
    te_dict = {}
    pairs = []
    genome_fasta_dict = read_genome_fasta(genome_fasta_path)
    ltr_clade_dict = read_ltr_clade(cls_file_path)
    with open(te_gff_file_path, 'r') as te_gff_file:
        for line in te_gff_file:
            group = line.strip().split()
            if group[2] == "long_terminal_repeat":
                chr_id, start, end, order, attribute = group[0], int(group[3]), int(group[4]), group[6], group[8]
                ltr_id, name = re.search(r"ID=(.*?);.*Name=(.*?);", attribute).group(1, 2)

                seq = get_fasta_by_coord(chr_id, start, end, genome_fasta_dict)
                if re.match(r"lLTR.*", ltr_id):
                    clade = ltr_clade_dict["start"].get((name, chr_id, start))
                if re.match(r"rLTR.*", ltr_id):
                    clade = ltr_clade_dict["end"].get((name, chr_id, end))

                te_dict[ltr_id] = name, clade, seq
                pair = re.search(r"[lr](LTR.*)", ltr_id).group(1)
                if pair not in pairs:
                    pairs.append(pair)
    return te_dict, pairs


def generate_ltr_pairs_fasta(args):
    try:
        os.makedirs("LTR_pairs")
    except FileExistsError:
        pass

    te_dict, pairs = read_ltr_pairs(args.gff, args.fa, args.cls)
    for p in pairs:
        l_seq_name, l_seq = te_dict["l" + p][0], te_dict["l" + p][2]
        r_seq_name, r_seq = te_dict["r" + p][0], te_dict["r" + p][2]
        if te_dict["l" + p][1] is None:
            continue
        pair_file_path = "LTR_pairs/" + p + "_" + te_dict["l" + p][1] + ".fa"
        with open(pair_file_path, 'w') as pair_file:
            pair_file.write(">" + l_seq_name + "_" + "l" + p + "\n" + str(l_seq) + "\n")
            pair_file.write(">" + r_seq_name + "_" + "r" + p + "\n" + str(r_seq) + "\n")


def main():
    logging.basicConfig(
        stream=sys.stderr,
        level=logging.INFO,
        format="[%(levelname)s] %(message)s"
    )

    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        description="Generate grouped intact LTR fasta files")

    parser.add_argument('-g', '--gff', required=True, help='intact LTR gff3 file, could be generated by EDTA')
    parser.add_argument('-f', '--fa', required=True, help='genome fasta file')
    parser.add_argument('-c', '--cls', required=True, help='subfamily cluster tsv file, could be generated by TEsorter')
    args = parser.parse_args()

    generate_ltr_pairs_fasta(args)


if __name__ == "__main__":
    main()
